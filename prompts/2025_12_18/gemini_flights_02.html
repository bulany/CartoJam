<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Global Itinerary Command</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; color: #0f0; }
        #crt-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), radial-gradient(circle, rgba(0,0,0,0) 70%, rgba(0,0,0,0.5) 100%);
            background-size: 100% 3px, 100% 100%; }

        /* UI */
        .panel { position: absolute; background: rgba(0, 15, 0, 0.85); border: 1px solid #0f0; padding: 12px; z-index: 20; box-shadow: 0 0 10px rgba(0,255,0,0.2); }
        #input-panel { top: 20px; left: 20px; width: 260px; }
        #status-panel { top: 20px; right: 20px; text-align: right; font-size: 0.8rem; line-height: 1.4; }
        #timeline-panel { bottom: 30px; left: 50%; transform: translateX(-50%); width: 85%; max-width: 700px; display: none; text-align: center; }

        input { background: #000; border: 1px solid #0f0; color: #0f0; padding: 6px; width: calc(100% - 14px); margin-bottom: 10px; text-transform: uppercase; }
        button { background: #0f0; color: #000; border: none; padding: 10px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 5px; }
        button:hover { background: #0c0; }
        
        input[type=range] { width: 100%; accent-color: #0f0; cursor: pointer; margin-top: 10px; }
        .label { font-size: 0.7rem; letter-spacing: 1px; margin-bottom: 4px; display: block; color: #0a0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="loading">DOWNLOAD DATABASE...</div>

    <div id="input-panel" class="panel">
        <span class="label">AIRPORT CODES (IATA)</span>
        <input type="text" id="route-input" placeholder="e.g. JFK, LHR, DXB, SIN" value="JFK, LHR, DXB, SIN">
        <button id="btn-plot">ESTABLISH VECTOR</button>
    </div>

    <div id="status-panel" class="panel">
        <div id="stat-route">IDLE</div>
        <div id="stat-dist">0.0 KM</div>
        <div id="stat-time">T+ 00:00</div>
    </div>

    <div id="timeline-panel" class="panel">
        <span class="label">MISSION PROGRESS SCRUBBER</span>
        <input type="range" id="time-slider" min="0" max="1000" value="0">
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        const GLOBE_RADIUS = 20;
        const JET_SPEED_KMH = 900; 
        const EARTH_RADIUS_KM = 6371;
        let airportDB = {};
        let segments = [];
        let totalTripDistance = 0;

        // --- SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(45, 25, 45);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.8));

        // --- DATA LOAD ---
        async function init() {
            try {
                // Fetch low-res coastlines
                const geoRes = await fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_coastline.geojson');
                const geoData = await geoRes.json();
                drawCoastlines(geoData);

                // Fetch Airport Database (IATA codes)
                const airRes = await fetch('./airports.json');
                airportDB = await airRes.json();

                document.getElementById('loading').style.display = 'none';
                
                // Check if URL has a saved route
                if(window.location.hash) {
                    document.getElementById('route-input').value = window.location.hash.substring(1).replaceAll('-', ', ');
                    plotRoute();
                }
            } catch(e) { console.error(e); }
        }

        function latLonToVec3(lat, lon, r) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            return new THREE.Vector3(
                -(r * Math.sin(phi) * Math.cos(theta)),
                (r * Math.cos(phi)),
                (r * Math.sin(phi) * Math.sin(theta))
            );
        }

        function drawCoastlines(data) {
            const pts = [];
            data.features.forEach(f => {
                const lines = f.geometry.type === 'LineString' ? [f.geometry.coordinates] : f.geometry.coordinates;
                lines.forEach(line => {
                    for (let i = 0; i < line.length - 1; i++) {
                        pts.push(latLonToVec3(line[i][1], line[i][0], GLOBE_RADIUS));
                        pts.push(latLonToVec3(line[i+1][1], line[i+1][0], GLOBE_RADIUS));
                    }
                });
            });
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            scene.add(new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0x004422 })));
            // Core sphere
            scene.add(new THREE.Mesh(new THREE.SphereGeometry(GLOBE_RADIUS * 0.99, 32, 32), new THREE.MeshBasicMaterial({ color: 0x000800 })));
        }

        // --- ROUTE LOGIC ---

        const routeGroup = new THREE.Group();
        scene.add(routeGroup);
        const pulse = new THREE.Mesh(new THREE.SphereGeometry(0.4, 12, 12), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        pulse.visible = false;
        scene.add(pulse);

        function plotRoute() {
            const input = document.getElementById('route-input').value.split(',').map(s => s.trim().toUpperCase());
            routeGroup.clear();
            segments = [];
            totalTripDistance = 0;

            let prevPoint = null;
            let prevCode = null;

            input.forEach((code, i) => {
                const airport = airportDB[code];
                if (!airport) return;

                const currPoint = latLonToVec3(parseFloat(airport.latitude), parseFloat(airport.longitude), GLOBE_RADIUS);
                
                // Add Airport Dot
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ffaa }));
                dot.position.copy(currPoint);
                routeGroup.add(dot);

                if (prevPoint) {
                    // Calculate Great Circle Distance
                    const angle = prevPoint.angleTo(currPoint);
                    const distKM = angle * EARTH_RADIUS_KM;
                    
                    // Create Arc
                    // Fix: The control point is the midpoint normalized and pulled OUT
                    const mid = new THREE.Vector3().addVectors(prevPoint, currPoint).multiplyScalar(0.5);
                    const height = GLOBE_RADIUS + (distKM / 1000); // 1 unit height per 1000km
                    const control = mid.clone().normalize().multiplyScalar(height);
                    
                    const curve = new THREE.QuadraticBezierCurve3(prevPoint, control, currPoint);
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(curve.getPoints(50));
                    routeGroup.add(new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.5 })));

                    segments.push({
                        curve: curve,
                        dist: distKM,
                        startCode: prevCode,
                        endCode: code,
                        cumDist: totalTripDistance
                    });
                    totalTripDistance += distKM;
                }

                prevPoint = currPoint;
                prevCode = code;
            });

            if (segments.length > 0) {
                document.getElementById('timeline-panel').style.display = 'block';
                document.getElementById('stat-route').innerText = input.join(' > ');
                window.location.hash = input.join('-');
                controls.autoRotate = false;
                updateProgress(0);
            }
        }

        function updateProgress(val) {
            const currentDist = (val / 1000) * totalTripDistance;
            
            // Find which segment we are in
            let segment = segments[0];
            for (let s of segments) {
                if (currentDist >= s.cumDist && currentDist <= (s.cumDist + s.dist)) {
                    segment = s;
                    break;
                }
                segment = s; // fallback to last
            }

            const localT = (currentDist - segment.cumDist) / segment.dist;
            const pos = segment.curve.getPoint(Math.min(Math.max(localT, 0), 1));
            pulse.position.copy(pos);
            pulse.visible = true;

            // UI Stats
            const totalHours = totalTripDistance / JET_SPEED_KMH;
            const currentHours = (val / 1000) * totalHours;
            document.getElementById('stat-dist').innerText = `${Math.floor(currentDist)} / ${Math.floor(totalTripDistance)} KM`;
            document.getElementById('stat-time').innerText = `T+ ${currentHours.toFixed(1)} HRS`;
        }

        // --- EVENTS ---
        document.getElementById('btn-plot').addEventListener('click', plotRoute);
        document.getElementById('time-slider').addEventListener('input', (e) => updateProgress(e.target.value));

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }

        init();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>