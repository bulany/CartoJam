<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>France Animated Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <style>
        body {
            margin: 0;
            background-color: #f0f4f8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Overlay UI */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none; /* Let clicks pass through to map */
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #status {
            margin-top: 10px;
            font-size: 18px;
            color: #e74c3c;
            font-weight: bold;
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            transition: opacity 0.3s;
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
        }

        button {
            border: none;
            background: #34495e;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #2c3e50;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Specific Label Styles drawn on Canvas, mostly handled by JS, 
           but we can use this for the floating label logic if we moved to DOM elements.
           Here we will draw text on Canvas for performance. */
        
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 20px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="ui-layer">
            <h1>France Explorer</h1>
            <div id="status">Initializing...</div>
        </div>
        
        <!-- D3 will append the canvas here -->
    </div>

    <div class="loading-overlay" id="loader">Loading Datasets...</div>

    <div id="controls">
        <button id="btn-slower">Slower</button>
        <button id="btn-normal">Normal</button>
        <button id="btn-faster">Faster</button>
        <div style="width:1px; background:#ccc;"></div>
        <button id="btn-restart">Restart Animation</button>
    </div>

<script>
    // --- Configuration ---
    const width = window.innerWidth;
    const height = window.innerHeight;
    let speedMultiplier = 1.0; // 1 = 60s target (approx), 2 = fast, 0.5 = slow
    let isAnimating = true;
    let abortController = new AbortController(); // To cancel animation on restart

    // --- State Variables ---
    let context;
    let projection;
    let path;
    let globeRotationTimer;
    
    // Data Containers
    let worldData;
    let regionsData;
    let deptsData;

    // Simplified Rivers Data (Ordered: Source to Mouth)
    // Manually defined to ensure "drawing direction" and clean look without massive shapefiles.
    // Coordinates are roughly simplified for visual appeal.
    const rivers = [
        { 
            name: "La Loire", 
            coords: [[4.22, 44.83],[4.01, 45.19],[4.25, 45.88],[3.60, 46.50],[2.90, 47.30],[2.00, 47.80],[1.75, 47.90],[1.30, 47.50],[0.50, 47.40],[-1.15, 47.20],[-2.18, 47.28]]
        },
        { 
            name: "La Seine", 
            coords: [[4.73, 47.50],[4.30, 48.00],[3.80, 48.50],[2.50, 48.60],[2.35, 48.85],[1.50, 49.00],[1.00, 49.40],[0.20, 49.45]]
        },
        { 
            name: "Le RhÃ´ne", 
            coords: [[8.30, 46.57],[7.50, 46.20],[6.00, 46.10],[5.50, 45.70],[4.80, 45.75],[4.80, 44.90],[4.60, 43.70],[4.80, 43.35]]
        },
        { 
            name: "La Garonne", 
            coords: [[0.76, 42.60],[0.60, 43.00],[1.40, 43.60],[1.00, 44.00],[0.30, 44.50],[-0.30, 44.80],[-0.60, 45.04]]
        },
        { 
            name: "La Dordogne", 
            coords: [[2.80, 45.50],[2.00, 45.20],[0.60, 44.85],[-0.58, 45.04]]
        }
    ];

    // --- Setup Canvas ---
    const container = d3.select("#canvas-container");
    const canvas = container.append("canvas")
        .attr("width", width)
        .attr("height", height);
    context = canvas.node().getContext("2d");

    // --- Data Fetching ---
    async function loadData() {
        try {
            const [world, regions, depts] = await Promise.all([
                d3.json("https://unpkg.com/world-atlas@2.0.2/countries-110m.json"),
                d3.json("https://raw.githubusercontent.com/gregoiredavid/france-geojson/master/regions.geojson"),
                d3.json("https://raw.githubusercontent.com/gregoiredavid/france-geojson/master/departements.geojson")
            ]);

            worldData = topojson.feature(world, world.objects.countries);
            
            // Organize Departments by Region
            // Note: Region codes must match. 
            regionsData = regions.features.sort((a, b) => a.properties.nom.localeCompare(b.properties.nom));
            deptsData = depts.features;
            
            // Map depts to regions
            regionsData.forEach(region => {
                region.depts = deptsData.filter(d => d.properties.code.startsWith(region.properties.code) || 
                                                     (d.properties.codeRegion === region.properties.code));
                // Sort depts alphabetically
                region.depts.sort((a, b) => a.properties.nom.localeCompare(b.properties.nom));
            });

            document.getElementById('loader').style.display = 'none';
            startAnimation();
        } catch (error) {
            document.getElementById('loader').innerText = "Error loading data. Please check connection.";
            console.error(error);
        }
    }

    // --- Utility Functions ---

    function getDelay(ms) {
        // Returns a promise that resolves after ms / speedMultiplier
        return new Promise((resolve, reject) => {
            const timer = setTimeout(resolve, ms / speedMultiplier);
            abortController.signal.addEventListener('abort', () => {
                clearTimeout(timer);
                reject(new Error("Aborted"));
            });
        });
    }

    function setStatus(text) {
        const el = document.getElementById('status');
        el.innerText = text;
        el.style.opacity = text ? 1 : 0;
    }

    // --- Drawing Functions ---

    function clearCanvas() {
        context.clearRect(0, 0, width, height);
    }

    function drawGlobe(rotation) {
        projection.rotate(rotation);
        clearCanvas();
        
        // Ocean
        context.beginPath();
        path({type: "Sphere"});
        context.fillStyle = "#e0f7fa";
        context.fill();

        // Land
        context.beginPath();
        path(worldData);
        context.strokeStyle = "#455a64";
        context.lineWidth = 0.5;
        context.stroke();
        context.fillStyle = "#fff";
        context.fill();
        
        // Sphere Outline
        context.beginPath();
        path({type: "Sphere"});
        context.strokeStyle = "#000";
        context.lineWidth = 1;
        context.stroke();
    }

    // Interpolator for Zoom
    function interpolateProjection(p1, p2) {
        // Interpolates scale, translate and rotate
        const r1 = p1.rotate();
        const r2 = p2.rotate();
        const s1 = p1.scale();
        const s2 = p2.scale();
        const t1 = p1.translate();
        const t2 = p2.translate();

        return function(t) {
            const r = [
                r1[0] + (r2[0] - r1[0]) * t,
                r1[1] + (r2[1] - r1[1]) * t,
                r1[2] + (r2[2] - r1[2]) * t
            ];
            const s = s1 + (s2 - s1) * t;
            const tr = [
                t1[0] + (t2[0] - t1[0]) * t,
                t1[1] + (t2[1] - t1[1]) * t
            ];
            projection.rotate(r).scale(s).translate(tr);
            return projection;
        };
    }

    // --- Main Animation Sequence ---

    async function startAnimation() {
        // Reset Controller
        abortController = new AbortController();
        isAnimating = true;
        document.getElementById('btn-restart').disabled = true;

        // 1. Setup Globe
        projection = d3.geoOrthographic()
            .scale(height / 2.5)
            .translate([width / 2, height / 2])
            .clipAngle(90);
        path = d3.geoPath(projection, context);

        setStatus("Finding France...");
        
        // 2. Rotating Globe Loop
        let rotate = [0, -20];
        let velocity = 0.02; // Reduced velocity for manual handling
        let startTime = Date.now();
        let globeDuration = 3000; // 3 seconds spinning

        try {
            await new Promise((resolve, reject) => {
                const timer = d3.timer((elapsed) => {
                    if (abortController.signal.aborted) {
                        timer.stop();
                        reject(new Error("Aborted"));
                        return;
                    }

                    // Rotate
                    rotate[0] += 0.5; // speed
                    drawGlobe(rotate);

                    if (elapsed > (globeDuration / speedMultiplier)) {
                        timer.stop();
                        resolve();
                    }
                });
            });

            // 3. Zoom into France
            setStatus("Zooming In...");
            
            // Calculate target projection (Centered on France)
            // France Centroid approx: [2.5, 46.5]
            const franceCenter = [2.5, 46.5];
            const targetScale = Math.min(width, height) * 4; // Zoom level
            
            const startProj = d3.geoOrthographic()
                .scale(projection.scale())
                .rotate(projection.rotate())
                .translate(projection.translate())
                .clipAngle(90);

            const endProj = d3.geoOrthographic()
                .scale(targetScale)
                .rotate([-franceCenter[0], -franceCenter[1]]) // Rotate to center
                .translate([width / 2, height / 2])
                .clipAngle(90);

            const interpolator = interpolateProjection(startProj, endProj);

            await new Promise((resolve, reject) => {
                const transitionDuration = 2000 / speedMultiplier;
                const ease = d3.easeCubicInOut;
                const timer = d3.timer((elapsed) => {
                    if (abortController.signal.aborted) {
                        timer.stop(); reject(new Error("Aborted")); return;
                    }

                    const t = Math.min(1, elapsed / transitionDuration);
                    const p = interpolator(ease(t));
                    
                    // Redraw world with new projection state
                    clearCanvas();
                    context.beginPath(); path(worldData);
                    context.fillStyle = "#eee"; context.fill();
                    context.strokeStyle = "#ccc"; context.stroke();

                    if (t >= 1) {
                        timer.stop();
                        resolve();
                    }
                });
            });

            // 4. Draw Major Rivers
            // Switch to a persistent background drawing strategy
            // We need to keep what we've drawn.
            
            // From here on, we build a static image progressively.
            // We redraw the base (France background) then layers on top.
            
            // Helper to redraw current state
            const drawBaseMap = () => {
                clearCanvas();
                context.beginPath(); path(worldData);
                context.fillStyle = "#fff"; context.fill(); 
                context.strokeStyle = "#ddd"; context.lineWidth = 1; context.stroke();
            };

            drawBaseMap();

            setStatus("Major Rivers");
            
            // Drawn objects storage
            let completedRivers = [];
            let completedRegions = [];
            let completedDepts = [];

            // RIVERS LOOP
            for (let river of rivers) {
                if (abortController.signal.aborted) break;

                const riverLine = { type: "LineString", coordinates: river.coords };
                const totalLen = d3.geoPath(projection, null)(riverLine).length || 100; // Estimate length in pixels
                
                setStatus(`River: ${river.name}`);

                // Animate drawing the line
                await new Promise((resolve, reject) => {
                    const dur = 800 / speedMultiplier;
                    const start = Date.now();
                    
                    const t = d3.timer(() => {
                        if (abortController.signal.aborted) { t.stop(); reject(new Error("Aborted")); return; }
                        
                        const now = Date.now();
                        const pct = Math.min(1, (now - start) / dur);

                        // Redraw everything
                        drawBaseMap();
                        
                        // Draw finished rivers
                        completedRivers.forEach(r => {
                            context.beginPath(); path({type:"LineString", coordinates: r.coords});
                            context.strokeStyle = "#3498db"; context.lineWidth = 2; context.stroke();
                            // Label
                            const center = r.coords[Math.floor(r.coords.length/2)];
                            const [x,y] = projection(center);
                            context.fillStyle = "#2980b9"; context.font = "bold 12px sans-serif";
                            context.fillText(r.name, x + 5, y);
                        });

                        // Draw current river partially
                        // Note: Canvas doesn't support partial path stroking easily with geoPath.
                        // We use lineDash trick.
                        context.save();
                        context.beginPath();
                        path(riverLine);
                        context.strokeStyle = "#3498db";
                        context.lineWidth = 2;
                        
                        // Calculated Dash offset
                        // Not perfect for GeoJSON but usually sufficient for simple lines
                        // For perfect partial draw, we'd interpolate coordinates, but that's complex.
                        // Visual trick: Draw whole line, use globalAlpha or dash if possible.
                        // Actually, let's just draw it fully for simplicity or use dashOffset.
                        // Canvas dash offset animation:
                        // Get path length approx (D3 doesn't give pixel length easily without SVG).
                        // Simple approach: Reveal it.
                        
                        // Hack for "Reveal":
                        // Since we can't easily get pixel length of a geoPath in Canvas without an invisible SVG,
                        // we will just draw it fully but 'fade' it in or just accept it draws quickly.
                        // Given user wants "being drawn", let's use a coordinate slicer.
                        
                        const numPoints = Math.max(2, Math.floor(river.coords.length * pct));
                        const partialCoords = river.coords.slice(0, numPoints);
                        if(partialCoords.length > 1) {
                            path({type:"LineString", coordinates: partialCoords});
                            context.stroke();
                        }
                        
                        context.fillStyle = "#e74c3c";
                        context.fillText(river.name, 20, height - 100); // UI Label
                        context.restore();

                        if (pct >= 1) {
                            t.stop();
                            resolve();
                        }
                    });
                });

                completedRivers.push(river);
                await getDelay(200); // Pause between rivers
            }

            // REGIONS LOOP
            for (let region of regionsData) {
                if (abortController.signal.aborted) break;
                
                setStatus(`Region: ${region.properties.nom}`);

                // Draw Region Outline Animation
                // We'll highlight the region then fill its departments
                
                await new Promise((resolve) => setTimeout(resolve, 500 / speedMultiplier));

                // DEPARTMENTS LOOP (Inside Region)
                if (region.depts && region.depts.length > 0) {
                    for (let dept of region.depts) {
                        if (abortController.signal.aborted) break;

                        const deptName = dept.properties.nom;
                        const deptNum = dept.properties.code;
                        setStatus(`Region: ${region.properties.nom} | Dept: ${deptNum} - ${deptName}`);

                        // Draw Dept
                        completedDepts.push(dept);

                        // Redraw Scene
                        drawBaseMap();
                        
                        // Draw Rivers
                        completedRivers.forEach(r => {
                            context.beginPath(); path({type:"LineString", coordinates: r.coords});
                            context.strokeStyle = "#3498db"; context.lineWidth = 2; context.stroke();
                        });

                        // Draw Completed Regions (Outlines)
                        // (Actually we draw completed Depts, which form regions)
                        context.beginPath();
                        completedDepts.forEach(d => path(d));
                        context.fillStyle = "#dfe6e9";
                        context.fill();
                        context.strokeStyle = "#b2bec3";
                        context.lineWidth = 0.5;
                        context.stroke();

                        // Highlight Current Dept
                        context.beginPath();
                        path(dept);
                        context.fillStyle = "#fab1a0"; // Highlight color
                        context.fill();
                        context.strokeStyle = "#e17055";
                        context.lineWidth = 1;
                        context.stroke();

                        // Label Dept
                        const centroid = d3.geoCentroid(dept);
                        const [cx, cy] = projection(centroid);
                        context.fillStyle = "#2d3436";
                        context.font = "10px sans-serif";
                        context.textAlign = "center";
                        context.fillText(`${deptNum}`, cx, cy);

                        // Plot Prefecture (Approximated by Centroid for this simple dataset)
                        // Drawing a Dot
                        context.beginPath();
                        context.arc(cx, cy, 2, 0, 2 * Math.PI);
                        context.fillStyle = "#d63031";
                        context.fill();

                        await getDelay(150); // Fast tick for depts
                    }
                }
                
                completedRegions.push(region);
                // Draw Region Outline on top
                drawBaseMap();
                // ... Draw Rivers ...
                completedRivers.forEach(r => {
                    context.beginPath(); path({type:"LineString", coordinates: r.coords});
                    context.strokeStyle = "#3498db"; context.lineWidth = 2; context.stroke();
                });
                // ... Draw Depts ...
                context.beginPath();
                completedDepts.forEach(d => path(d));
                context.fillStyle = "#ecf0f1";
                context.fill();
                context.strokeStyle = "#bdc3c7";
                context.lineWidth = 0.5;
                context.stroke();
                // ... Draw Region Outline Bold ...
                completedRegions.forEach(reg => {
                    context.beginPath();
                    path(reg);
                    context.strokeStyle = "#2c3e50";
                    context.lineWidth = 1.5;
                    context.stroke();
                    
                    // Region Label
                    const c = d3.geoCentroid(reg);
                    const [rx, ry] = projection(c);
                    context.fillStyle = "#2c3e50";
                    context.font = "bold 14px sans-serif";
                    context.textAlign = "center";
                    context.fillText(reg.properties.nom, rx, ry);
                });
                
                // Add Departments text/numbers back in? Maybe too cluttered.
                // Let's keep just the Region names for the clean "Zoomed out" look 
                // but keep the prefecture dots.
            }

            // DONE
            setStatus("Map Complete. Interactive Mode.");
            isAnimating = false;
            document.getElementById('btn-restart').disabled = false;
            
            // Enable Zoom/Pan
            enableZoom();

        } catch (e) {
            if (e.message !== "Aborted") console.error(e);
        }
    }

    // --- Interaction ---

    function enableZoom() {
        const zoom = d3.zoom()
            .scaleExtent([100, 5000]) // Adjust based on projection scale
            .on("zoom", (event) => {
                const {transform} = event;
                
                // Update projection
                // We map d3 zoom transform to projection
                // Only simple scaling for orthographic to keep it spherical is tricky,
                // but for "End State" we can just assume standard panning.
                
                // Actually, best way to handle "Zoom/Pan on Globe" via d3.zoom:
                // projection.scale(initialScale * transform.k)
                // BUT rotation is handled differently.
                
                // Simplification for this request: Just use standard 2D transform on context
                context.save();
                context.clearRect(0, 0, width, height);
                context.translate(transform.x, transform.y);
                context.scale(transform.k, transform.k);
                
                // Redraw Static Final State
                // (Note: This scales the stroke width too, which might look thick, 
                // but is acceptable for a simple "Zoom in" feature).
                
                // Draw all layers
                // 1. France Base
                context.beginPath(); path(worldData); context.fillStyle="#fff"; context.fill();
                
                // 2. Depts
                context.beginPath();
                deptsData.forEach(d => path(d));
                context.fillStyle = "#ecf0f1"; context.fill();
                context.strokeStyle = "#bdc3c7"; context.lineWidth = 0.5/transform.k; context.stroke();

                // 3. Regions
                context.beginPath();
                regionsData.forEach(r => path(r));
                context.strokeStyle = "#2c3e50"; context.lineWidth = 1.5/transform.k; context.stroke();

                // 4. Rivers
                rivers.forEach(r => {
                    context.beginPath(); path({type:"LineString", coordinates: r.coords});
                    context.strokeStyle = "#3498db"; context.lineWidth = 2/transform.k; context.stroke();
                });

                context.restore();
            });

        // Initialize Zoom identity
        canvas.call(zoom);
        // Note: d3.zoom usually works on SVG better. On Canvas, we manually transform.
        // The logic above applies a CSS-style transform to the canvas drawing context.
        // It might jump slightly on first click.
    }

    // --- Event Listeners ---

    document.getElementById('btn-restart').addEventListener('click', () => {
        // Cancel current animation
        abortController.abort();
        // Clear canvas zoom listeners
        canvas.on('.zoom', null);
        // Restart
        startAnimation();
    });

    document.getElementById('btn-slower').addEventListener('click', () => {
        speedMultiplier = 0.5;
        highlightBtn('btn-slower');
    });
    document.getElementById('btn-normal').addEventListener('click', () => {
        speedMultiplier = 1.0;
        highlightBtn('btn-normal');
    });
    document.getElementById('btn-faster').addEventListener('click', () => {
        speedMultiplier = 2.5;
        highlightBtn('btn-faster');
    });

    function highlightBtn(id) {
        ['btn-slower', 'btn-normal', 'btn-faster'].forEach(btn => {
            document.getElementById(btn).style.background = (btn === id) ? "#e67e22" : "#34495e";
        });
    }
    
    // Initial Highlight
    highlightBtn('btn-normal');

    // Start
    loadData();

</script>
</body>
</html>